:title: Setting Up Keycloak as a Credential Issuer with OpenID4VCI
:date: 2025-12-02
:publish: true
:author: Rodrick Awambeng, Forkim Enjeckayang, Ingrid Kamga, Bertrand Ogen
:summary: Keycloak can act as a verifiable credential issuer using OpenID4VCI, allowing users to receive verifiable credentials as digital proofs of identity. This guide walks through the required configuration steps.

Keycloak implements https://openid.net/specs/openid-4-verifiable-credential-issuance-1_0.html[OpenID for Verifiable Credential Issuance] (OpenID4VCI). This functionality allows Keycloak to issue verifiable credentials (VCs) as a digital proof of identity or attributes. Enabling this functionality requires consistent configuration across several components, including the realm, client, and issuable credentials (as client scopes).

For example, consider the following scenario: The Keycloak OAuth SIG team wants to issue verifiable membership credentials to its members, including their name and email, which can later be presented at onsite or virtual events as proof of active membership.

NOTE: At the time of writing this blog, Keycloak's support for OpenID4VCI is still experimental. This guide uses the **main branch snapshot version** `999.0.0-SNAPSHOT`, and the feature is expected to be promoted to preview in early 2026.

== Introduction to OpenID4VCI

OpenID4VCI is a protocol developed by the OpenID Foundation that extends the OpenID Connect (OIDC) framework to enable the secure and standardized issuance of verifiable credentials (VCs). VCs are digital, tamper-evident representations of information, such as identity attributes or qualifications, that can be cryptographically verified without contacting the issuer at verification time. This promotes decentralized identity management, where users (holders) control their data and share it selectively with verifiers.

++++
<div class="paragraph" style="margin-top:1em;margin-bottom:2em;">
    <img src="${blogImages}/openid4vci/triangle-of-trust.png" alt="Triangle of trust or Issuer-Holder-Verifier model" style="border:none;display:block;max-width:100%;height:auto;margin:0 auto;">
    <p style="text-align:center;font-style:italic">Triangle of trust or Issuer-Holder-Verifier model</p>
</div>
++++

=== Why Use OpenID4VCI

The primary motivations for adopting OpenID4VCI include:

- **Interoperability**: Builds on established OIDC standards, simplifying integration with existing identity providers.
- **Privacy and Security**: Supports selective disclosure (e.g., proving age without revealing birthdate) and offline verification.
- **Compliance and Use Cases**: Aligned with regulations like eIDAS 2.0; useful for digital wallets, memberships, and qualifications.
- **Efficiency**: Leverages OIDC mechanisms to streamline issuance while maintaining trust in the "triangle of trust" model (Issuer-Holder-Verifier).

OpenID4VCI supports multiple credential formats, such as **SD-JWT VC**, **JWT VC**, and **mDL/mdoc**, and is designed for scenarios where issuers need to provide portable, verifiable digital proofs.

=== Key Flows in OpenID4VCI

OpenID4VCI defines two primary flows for credential issuance: the **Authorization Code Flow** and the **Pre-Authorized Code Flow**. These flows determine how a wallet (holder’s application) obtains an access token to request a VC from the issuer.

==== Authorization Code Flow

The Authorization Code Flow is **interactive** and requires the holder to authenticate and consent at the issuer’s authorization endpoint. It is ideal for scenarios where explicit user approval is required, or additional claims must be collected.

**Steps:**

1. The **Wallet** sends an Authorization Request to the **Issuer’s Authorization Endpoint**, requesting credentials.
2. The **Issuer** authenticates the **User** and requests consent for the issuance.
3. The **User** provides credentials and grants consent.
4. The **Issuer** returns an **Authorization Code** to the Wallet.
5. The **Wallet** exchanges the code at the **Issuer Token Endpoint** for an **Access Token**.
6. The **Wallet** requests the **Verifiable Credential** from the **Issuer Credential Endpoint** using the Access Token.
7. The **Issuer** returns the **VC** to the Wallet.

++++
<div class="paragraph" style="margin-top:1em;margin-bottom:2em;">
    <img src="${blogImages}/openid4vci/authorization-code-flow.png" alt="Authorization Code Flow Diagram" style="border:none;display:block;max-width:100%;height:auto;margin:0 auto;">
    <p style="text-align:center;font-style:italic">Sequence diagram: Authorization Code Flow</p>
</div>
++++

==== Pre-Authorized Code Flow

The Pre-Authorized Code Flow is **non-interactive**. The issuer pre-authenticates and authorizes the user, providing a **pre-authorized code** (often via QR code). It is faster and suitable for pre-approved credential issuance.

**Steps:**

1. The **Issuer** provides a **Pre-Authorized Code** to the **Wallet** (e.g., via QR code or link).
2. The **Wallet** exchanges the code at the **Issuer Token Endpoint** for an **Access Token**.
3. The **Wallet** requests the **Verifiable Credential** from the **Issuer Credential Endpoint** using the Access Token.
4. The **Issuer** returns the **VC** to the Wallet.

++++
<div class="paragraph" style="margin-top:1em;margin-bottom:2em;">
    <img src="${blogImages}/openid4vci/pre-authorized-code-flow.png" alt="Pre-Authorized Code Flow Diagram" style="border:none;display:block;max-width:100%;height:auto;margin:0 auto;">
    <p style="text-align:center;font-style:italic">Sequence diagram: Pre-Authorized Code Flow</p>
</div>
++++

Now that we’ve covered the technical flows, let’s explore the broader context and applications of verifiable credentials. Verifiable credentials allow relying parties to independently verify user identities or attributes without needing to contact the issuer directly.

Examples include:

- Governments issuing digital identity cards or driver’s licenses that citizens can present when booking hotels, opening bank accounts, or accessing public services.
- City councils issuing verifiable birth certificates that universities and hospitals can validate without a central lookup.
- Universities issuing digital diplomas that employers can instantly verify for authenticity.
- Companies issuing employee badges as verifiable credentials for office access or remote authentication.
- Event organizers issuing verifiable tickets that can be validated offline.
- Professional associations issuing membership credentials such as in our OAuth SIG example for verifying access to gated resources or conference venues.

These examples illustrate the variety of situations where verifiable credentials remove the need for direct communication between verifier and issuer while preserving trust.

== Configuring Keycloak for OpenID4VCI

OpenID4VCI in Keycloak is offered via the feature flag `oid4vc-vci`, which consequently needs to be enabled at startup.

[source,bash]
----
--features=oid4vc-vci
----

That said, we now assume that you have a running Keycloak instance with the `oid4vc-vci` feature flag enabled.

Beyond enabling the feature flag, the following configuration steps need to be taken consistently, in accordance with your use case:

- Configure OpenID4VCI at the realm level
- Configure an issuable verifiable credential (as a dedicated client scope)
- Enable and configure OpenID4VCI at the client level

Because some configurations are not yet supported via the Keycloak Admin Console, we may often use the Admin REST API to communicate required configurations.

=== Configuring OpenID4VCI at the realm level

Let's assume you have already created a realm named `oauth-sig-realm` to represent the OAuth SIG group, and that a couple of users have also been created in this realm, each with a password assigned, to represent members of the group.

In addition, any user who is intended to create credential offers must be granted the `credential-offer-create` role. This ensures that only authorized users can generate credential offers, maintaining the security of the issuance process.

--
++++
<img src="${blogImages}/openid4vci/screenshot-realm-and-users.png" style="margin-bottom:2em" alt="Screenshot: Realm and Users">
++++
--

The behavior of OpenID4VCI across the entire realm can be modulated via realm attributes.
On the Admin Console, find the *OID4VCI Attributes* section under the *Realm Settings > Tokens* tab.

--
++++
<img src="${blogImages}/openid4vci/screenshot-realm-config-oid4vci-attributes.png" style="margin-bottom:2em" alt="Screenshot: OID4VCI Attributes">
++++
--

Sensible defaults apply out of the box, but for the sake of this demo, we would want, for instance, to increase the value of **Pre-Authorized Code Lifespan** to 3 minutes so that the issuance flow expires less quickly.
To learn more about the **Nonce Lifetime** and other realm attributes for OpenID4VCI not accessible via the Admin Console, please refer to the main https://github.com/keycloak/keycloak/blob/main/docs/documentation/server_admin/topics/oid4vci/vc-issuer-configuration.adoc[Keycloak documentation].

Lastly, because EC cryptography is highly encouraged in the OpenID4VC ecosystem, we also invite you to add an EC key pair to the realm's set of keys under *Realm Settings > Keys > Providers*.
This will later enable configuring the signing of issued VCs with algorithm `ES256`.

--
++++
<img src="${blogImages}/openid4vci/screenshot-realm-ecdsa-generated-provider.png" style="margin-bottom:2em" alt="Screenshot: Adding ECDSA Key Provider">
++++
--

=== Configuring an issuable verifiable credential (as a dedicated client scope)

Different credential types can be configured for issuance depending on what data the credential should embed, what format it should have, or other criteria.
Each credential type is configured as a dedicated client scope of protocol type "OpenID for Verifiable Credentials".

We will configure our membership credential to be issued as an SD-JWT credential carrying a user's first name, last name, and email.
Each claim to be added to the credential requires a corresponding protocol mapper from the User Model to the credential.
Other fields such as the time of issuance or a unique identifier for the credential are supported via other types of protocol mappers.

Since we will be using the Admin REST API to configure the client scope, we first need to obtain a valid Admin Token from the `master` realm to authorize our requests.

[source,sh]
----
ADMIN_TOKEN=$(curl -s -X POST "http://<keycloak.instance>/realms/master/protocol/openid-connect/token" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "username=<admin-username>" \
  -d "password=<admin-password>" \
  -d "grant_type=password" \
  -d "client_id=admin-cli" | jq -r '.access_token' )
echo "Admin Token obtained: $ADMIN_TOKEN"
----

Now, let's proceed with adding the membership credential type as a dedicated client scope using the Admin REST API.

[source,sh]
----
curl -X POST "http://<keycloak.instance>/admin/realms/oauth-sig-realm/client-scopes" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $ADMIN_TOKEN" \
  -d '{
    "name": "membership-credential",
    "protocol": "oid4vc",
    "attributes": {
      "include.in.token.scope": "true",
      "vc.format": "dc+sd-jwt",
      "vc.verifiable_credential_type": "https://credentials.example.com/oauth-sig-membership",
      "vc.proof_signing_alg_values_supported": "ES256",
      "vc.display": "[{\"name\": \"OAuth SIG Membership\", \"locale\":\"en\"}]",
      "vc.credential_build_config.token_jws_type": "dc+sd-jwt"
    },
    "protocolMappers": [
      {
        "name": "given_name-mapper",
        "protocol": "oid4vc",
        "protocolMapper": "oid4vc-user-attribute-mapper",
        "config": {
          "claim.name": "given_name",
          "userAttribute": "firstName",
          "vc.display": "[{\"name\":\"Given Name\",\"locale\":\"en\"}]"
        }
      },
      {
        "name": "family_name-mapper",
        "protocol": "oid4vc",
        "protocolMapper": "oid4vc-user-attribute-mapper",
        "config": {
          "claim.name": "family_name",
          "userAttribute": "lastName",
          "vc.display": "[{\"name\":\"Family Name\",\"locale\":\"en\"}]"
        }
      },
      {
        "name": "email-mapper",
        "protocol": "oid4vc",
        "protocolMapper": "oid4vc-user-attribute-mapper",
        "config": {
          "claim.name": "email",
          "userAttribute": "email",
          "vc.display": "[{\"name\":\"Email\",\"locale\":\"en\"}]"
        }
      },
      {
        "name": "iat-mapper",
        "protocol": "oid4vc",
        "protocolMapper": "oid4vc-issued-at-time-claim-mapper",
        "config": {
          "claim.name": "iat",
          "truncateToTimeUnit": "HOURS",
          "valueSource": "COMPUTE"
        }
      }
    ]
  }'
----

Commenting on the above configuration:

- Attribute `vc.format` defines the format of the credential whereas `vc.verifiable_credential_type` specifies the `vct` property's value.
- All `vc.display` entries are intended to be used by a wallet to display intelligible descriptions.
- Known bugs mandate configuring the credential signing algorithm via `vc.proof_signing_alg_values_supported`.
- To learn more about other used or available configuration attributes, please refer to the main https://github.com/keycloak/keycloak/blob/main/docs/documentation/server_admin/topics/oid4vci/vc-issuer-configuration.adoc#create-client-scopes-with-mappers[Keycloak documentation].

Verify that the client scope was created successfully by checking the Admin Console under *Client Scopes*.
Additionally, place a GET call on the Credential Issuer Metadata Endpoint to verify that the newly created credential type is listed among issuable credentials, in accordance with the above configuration.

[source,sh]
----
curl -X GET "http://<keycloak.instance>/.well-known/openid-credential-issuer/realms/oauth-sig-realm" \
  -H "Accept: application/json"
----

[source,json5]
----
{
  // ...
  "credential_configurations_supported": {
    "membership-credential": {
      "id": "membership-credential",
      "format": "dc+sd-jwt",
      "scope": "membership-credential",
      "cryptographic_binding_methods_supported": [
        "jwk"
      ],
      "credential_signing_alg_values_supported": [
        "ES256"
      ],
      "vct": "https://credentials.example.com/oauth-sig-membership",
      //...
    }
  }
  // ...
}
----

=== Enabling OpenID4VCI at the client level

Next, let's create a new client in the `oauth-sig-realm` realm to represent an application that members of the OAuth SIG will use to request and receive their membership credentials.
We will name this client `oauth-sig-client` and configure it as a standard OpenID Connect client.

During client creation, make sure to check the **Direct Access Grants** box, as we will use the *Resource Owner Password Credentials* (ROPC) flow to obtain a user access token in a later step. All other fields are left unchanged.

--
++++
<img src="${blogImages}/openid4vci/screenshot-client-creation.png" style="margin-bottom:2em" alt="Screenshot: Client Creation">
++++
--

One important point to note is that clients must explicitly enable OpenID4VCI to be able to use it.
Navigate to the *Advanced* tab of the `oauth-sig-client` client and toggle the **Enable OID4VCI** switch under the *OpenID for Verifiable Credentials* section.

--
++++
<img src="${blogImages}/openid4vci/screenshot-client-enable-oid4vci.png" style="margin-bottom:2em" alt="Screenshot: Enable OID4VCI on Client">
++++
--

Finally, we need to assign the previously created `membership-credential` client scope to the `oauth-sig-client` client. To do this, navigate to the **Client Scopes** tab of the `oauth-sig-client` client and add `membership-credential` as an **Optional Client Scope**.

--
++++
<img src="${blogImages}/openid4vci/screenshot-assign-credential-type-to-client.png" style="margin-bottom:2em" alt="Screenshot: Assigning membership-credential client scope to the client">
++++
--

== Obtaining a User Access Token

Before obtaining the user access token, ensure that the user has the `credential-offer-create` role, as only users with this role can create credential offers.

With the client configured and the user's password set, we can now request a *user access token*. This token will later be used to authorize the credential offer request.

[source,sh]
----
USER_TOKEN=$(curl -s -X POST "http://<keycloak.instance>/realms/oauth-sig-realm/protocol/openid-connect/token" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "username=<user-username>" \
  -d "password=<user-password>" \
  -d "grant_type=password" \
  -d "client_id=oauth-sig-client" | jq -r '.access_token' )
echo "User Access Token obtained: $USER_TOKEN"
----

Now that we have a *user access token* issued to the user with the `credential-offer-create` role, we can use it to request a credential offer from the Keycloak issuer in the next step.

== Retrieving a credential offer to start the issuance flow

For Pre-Authorized Code flows, OpenID4VCI issuance can be initiated by retrieving a credential offer from Keycloak at the Credential Offer Endpoint. The endpoint requires a valid user access token and the target user ID for the pre-authorized offer. 
In our case, we will be using the same user for both credential offer creation and retrieval.

[source,sh]
----
curl -X GET "http://<keycloak.instance>/realms/oauth-sig-realm/protocol/oid4vc/credential-offer-uri?credential_configuration_id=membership-credential&type=qr-code&user_id=<username>" \
  -H "Authorization: Bearer $USER_TOKEN" \
  --output credential-offer-qr.png
----

NOTE: Replace `<username>` with the user you created earlier.
The QR code image is saved as `credential-offer-qr.png`. Open this file and use your wallet to redeem the credential.

With the query parameter `type=qr-code`, the endpoint returns a *direct binary representation of the QR code image*. If omitted, the endpoint returns JSON, which requires extra steps to construct the QR code from the offer data.

--
++++
<div class="paragraph" style="margin-top:1em;margin-bottom:2em;">
    <img src="${blogImages}/openid4vci/qrcode-generation-overview.png" alt="QR Code Generation Overview" style="border:none;display:block;max-width:800px;height:auto;margin:0 auto;">
</div>
++++
--

Upon scanning the QR code with a compatible wallet, a membership credential is issued to the requesting user.

### ⚠️ Wallet Compatibility Notice

Keycloak implements the **final OpenID4VCI specification**, but also provides **backward compatibility with Draft-15** to support existing wallets.

The following wallets (still on Draft-15) were tested and work with Keycloak:

[cols="1,1", options="header"]
|===
| Wallet | Compatibility

| **Heidi Wallet**
| ✅ Works via Draft-15 backward compatibility

| **Valera Wallet**
| ✅ Works via Draft-15 backward compatibility

| **Lissi Wallet**
| ✅ Works via Draft-15 backward compatibility
|===

--
++++
<div class="paragraph" style="margin-top:1em;margin-bottom:2em;">
    <img src="${blogImages}/openid4vci/screenshot-wallet-steps.png" alt="Screenshot: Wallet Steps" style="border:none;display:block;max-width:100%;height:auto;margin:0 auto;">
    <p style="text-align:center;font-style:italic">Screenshot: Lissi Wallet Test</p>
</div>
++++
--

== Before You Go

In this blog post, we have illustrated how to set up Keycloak for issuing verifiable credentials over OpenID4VCI, using a simple scenario of issuing membership credentials to members of the OAuth SIG group.
We covered the necessary configuration steps at the realm, client scope, and client levels, and demonstrated how to retrieve a credential offer to initiate the issuance flow.
If you are looking into streamlining this configuration process for OpenID4VCI in Keycloak, take a look at our https://github.com/keycloak/keycloak-oauth-sig/tree/main/oid4vci-deployment#readme[OID4VCI Deployment] project, which has solid examples for both the preauthorization and authorization code flows.